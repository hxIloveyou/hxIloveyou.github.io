<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94SoX/"/>
    <url>/2020/12/29/%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94SoX/</url>
    
    <content type="html"><![CDATA[<h1 id="音频处理工具——SoX"><a href="#音频处理工具——SoX" class="headerlink" title="音频处理工具——SoX"></a>音频处理工具——SoX</h1><p>SoX是一款非常强大的音频处理程序，是一个跨平台，支持命令行的程序，可以改变音频格式，在大多数平台上支持运行和记录音频文件。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li>获取音频文件的元数据</li></ol><blockquote><p><code>soxi</code> 或者<code>sox --i</code> </p></blockquote><p><code>soxi</code> 命令可以通过分析音频文件的文件头，获取其基本信息（通道数，采样率，码率等）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage: soxi [-V[level]] [-T] [-t|-r|-c|-s|-d|-D|-b|-B|-p|-e|-a] infile1 ...<br></code></pre></td></tr></table></figure><p>用法为<code>sox [-B|-t|...] inputfile</code></p><ol start="2"><li>获取音频的统计信息</li></ol><blockquote><p><code>sox &lt;inputfile&gt; -n stat</code></p></blockquote><p>使用<code>sox &lt;inputfile&gt; -n stat</code>命令获取音频文件的统计信息，如振幅，时长，最大音量调节幅度（不失真）等等</p><ol start="3"><li>播放与录制音频</li></ol><blockquote><p><code>play</code> 和 <code>rec</code> 提供了基本的播放录制功能  </p></blockquote><p>播放音频：<code>$ play &lt;existing-file&gt;</code></p><p>录制音频：<code>$ rec &lt;new-file&gt;</code></p><p>等同于使用<code>sox -d</code>命令</p><p><code>$ sox &lt;existing-file&gt; -d</code> 表示从<code>&lt;existing-file&gt;</code>中读取其包含的音频数据，在<code>-d</code> 输出到（默认音频设备-扬声器）进行播放</p><p><code>$ sox -d &lt;new-file&gt; </code> 表示从<code>-d</code>（默认音频设备-麦克风）中读取音频，再输出（录制）到<code>&lt;new-file&gt;</code>文件中</p><p><code>sox</code>处理音频的基本流程就是：<code>Input(s) -&gt; Combiner -&gt; Effects -&gt; Output(s)</code></p><p>其中在录制过程中都遵循了<code>sox &lt;input&gt; &lt;output&gt;</code>的方式，可以自定义输入输出设备attach    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><h4 id="1-根据目的来分"><a href="#1-根据目的来分" class="headerlink" title="1. 根据目的来分"></a>1. 根据目的来分</h4><p> 根据模式是<strong>用来完成什么工作</strong>来划分，这种方式可分为创建型模式、结构型模、行为型模式。</p><ol><li> <font color="red">创建型模式</font>：用于描述“怎样创建对象”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li><li> <font color="red">结构型模式</font>：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li><li> <font color="red">行为型模式</font>：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 </li></ol><h4 id="2-根据作用范围来分"><a href="#2-根据作用范围来分" class="headerlink" title="2. 根据作用范围来分"></a>2. 根据作用范围来分</h4><p> 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式、对象模式。</p><ol><li> <font color="red">类模式</font>：用于处理类与子类之间的关系，这些关系通过<strong>继承</strong>来建立，是<strong>静态</strong>的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li> <font color="red">对象模式</font>：用于处理对象之间的关系，这些关系可以通过<strong>组合或聚合</strong>来实现，在运行时刻是可以变化的，更具<strong>动态</strong>性。GoF 中除了以上 4 种，其他的都是对象模式。</li></ol><table><thead><tr><th>范围\目的</th><th>创建型模式</th><th>结构型模式</th><th align="left">行为型模式</th></tr></thead><tbody><tr><td>类模式</td><td>工厂方法</td><td>(类）适配器</td><td align="left">模板方法<br />解释器</td></tr><tr><td>对象模式</td><td>单例<br />原型<br />抽象工厂<br /> 建造者</td><td>代理<br /> (对象）适配器<br />桥接<br />装饰<br />外观<br />享元<br />组合</td><td align="left">策略<br /> 命令<br /> 职责链<br /> 状态<br /> 观察者<br /> 中介者<br /> 迭代器<br /> 访问者<br /> 备忘录</td></tr></tbody></table><h3 id="23种设计模式的功能"><a href="#23种设计模式的功能" class="headerlink" title="23种设计模式的功能"></a>23种设计模式的功能</h3><ol><li><font color="red">单例（Singleton）模式</font>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li> <font color="red">原型（Prototype）模式</font>：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li> <font color="red">工厂方法（Factory Method）模式</font>：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li> <font color="red">抽象工厂（AbstractFactory）模式</font>：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li> <font color="red">建造者（Builder）模式</font>：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li> <font color="#D2691E">代理（Proxy）模式</font>：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li> <font color="#D2691E">适配器（Adapter）模式</font>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li> <font color="#D2691E">桥接（Bridge）模式</font>：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li> <font color="#D2691E">装饰（Decorator）模式</font>：动态的给对象增加一些职责，即增加其额外的功能。</li><li> <font color="#D2691E">外观（Facade）模式</font>：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li> <font color="#D2691E">享元（Flyweight）模式</font>：运用共享技术来有效地支持大量细粒度对象的复用。</li><li> <font color="#D2691E">组合（Composite）模式</font>：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li> <font color="##1E90FF">模板方法（TemplateMethod）模式</font>：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li> <font color="##1E90FF">策略（Strategy）模式</font>：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li> <font color="##1E90FF">命令（Command）模式</font>：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li> <font color="##1E90FF">职责链（Chain of Responsibility）模式</font>：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li> <font color="##1E90FF">状态（State）模式</font>：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li> <font color="##1E90FF">观察者（Observer）模式</font>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li> <font color="##1E90FF">中介者（Mediator）模式</font>：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li> <font color="##1E90FF">迭代器（Iterator）模式</font>：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li> <font color="##1E90FF">访问者（Visitor）模式</font>：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li> <font color="##1E90FF">备忘录（Memento）模式</font>：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li> <font color="##1E90FF">解释器（Interpreter）模式</font>：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><h2 id="类图的相关概念和相关关系"><a href="#类图的相关概念和相关关系" class="headerlink" title="类图的相关概念和相关关系"></a>类图的相关概念和相关关系</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类（Class）是指具有相同属性、方法和关系的对象的<strong>抽象</strong>，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有<font color="red">封装性、继承性和多态性</font>等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。</p><ol><li>类名（Name）是一个字符串，例如，Student。</li><li>属性（Attribute）是指类的特性，即类的成员变量。</li></ol><blockquote><p> [可见性]属性名:类型[=默认值]</p></blockquote><p><a href="%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%90%8C%E6%A0%B7%E4%B9%9F%E9%80%82%E7%94%A8%E4%BA%8E%E6%96%B9%E6%B3%95%E3%80%82%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BA%94%E8%AF%A5%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%81%9A%E5%A5%BD%E4%B8%80%E4%BB%B6%E4%BA%8B%E6%83%85%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E7%9A%84%E4%BA%8B%E6%83%85%E5%A4%AA%E5%A4%9A%EF%BC%8C%E5%85%B6%E9%A2%97%E7%B2%92%E5%BA%A6%E4%BC%9A%E5%8F%98%E5%BE%97%E5%BE%88%E7%B2%97%EF%BC%8C%E4%B8%8D%E5%88%A9%E4%BA%8E%E9%87%8D%E7%94%A8%E3%80%82">^ 注</a>: <font color="red">“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。</font><br>3. 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。</p><blockquote><p>[可见性]名称(参数列表)[:返回类型]</p></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><font color="red">接口（Interface）</font>是一种特殊的类，它具有类的结构但<strong>不可被实例化</strong>，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><font color="red">类图（ClassDiagram）</font>是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。</p><p>类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的<strong>耦合度</strong>从弱到强排列，UML 中的类图有以下几种关系：<font color="red">依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的</font>。</p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p><font color="red">依赖（Dependency）关系</font>是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。</p><p>在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</p><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p><font color="red">关联（Association）关系</font>是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。关联可以是双向的，也可以是单向的。</p><p>在代码中，通常将一个类的对象作为另一个类的成员变量来实现关联关系。</p><p>在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p><font color="red">聚合（Aggregation）关系</font>是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 <font color="red"><strong>has-a</strong></font> 的关系。</p><p>在代码中，聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。</p><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 <font color="red"><strong>cxmtains-a</strong></font> 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。</p><h4 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h4><p><font color="red">泛化（Generalization）关系</font>是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 <font color="red"><strong>is-a</strong></font> 的关系。</p><p>在代码实现时，使用面向对象的继承机制来实现泛化关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。</p><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p><font color="red">实现（Realization）关系</font>是接口与实现类之间的关系。</p><p>在代码实现中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p><h2 id="设计模式的七个原则"><a href="#设计模式的七个原则" class="headerlink" title="设计模式的七个原则"></a>设计模式的七个原则</h2><h3 id="开闭原则（Open-Closed-Principle，OCP）"><a href="#开闭原则（Open-Closed-Principle，OCP）" class="headerlink" title="开闭原则（Open Closed Principle，OCP）"></a>开闭原则（Open Closed Principle，OCP）</h3><h4 id="开闭原则的定义"><a href="#开闭原则的定义" class="headerlink" title="开闭原则的定义"></a>开闭原则的定义</h4><p><font color="red">软件实体应当对<strong>扩展</strong>开放，对<strong>修改</strong>关闭（Software entities should be open for extension，but closed for modification）</font></p><p>软件实体包括：项目中划分出来的模块，类与接口，方法</p><p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h4 id="开闭原则的作用"><a href="#开闭原则的作用" class="headerlink" title="开闭原则的作用"></a>开闭原则的作用</h4><ul><li>遵守开闭原则，软件测试时只需对扩展的代码进行测试，对原代码无影响，仍可以继续运行</li><li>代码的粒度越小，可复用性越大，在面对对象程序设计中，根据原子和抽象编程可以提高代码的可复用性</li><li>可以提高软件的可维护性，其稳定性和延续性强</li></ul><h4 id="开闭原则的实现方法"><a href="#开闭原则的实现方法" class="headerlink" title="开闭原则的实现方法"></a>开闭原则的实现方法</h4><p>通过“抽象约束，封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>示例：Windows换桌面背景图片和主题</p><h3 id="里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle，LSP）"></a>里氏替换原则（Liskov Substitution Principle，LSP）</h3><h4 id="里氏替换原则的定义"><a href="#里氏替换原则的定义" class="headerlink" title="里氏替换原则的定义"></a>里氏替换原则的定义</h4><p><font color="red">继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）</font></p><p>里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h4 id="里氏替换原则的作用"><a href="#里氏替换原则的作用" class="headerlink" title="里氏替换原则的作用"></a>里氏替换原则的作用</h4><ul><li>里氏替换原则是实现开闭原则的重要方式之一</li><li>里氏替换原则克服了继承中重写父类造成的可复用性变差的缺点</li><li>是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误。</li></ul><h4 id="里氏替换原则的实现方法"><a href="#里氏替换原则的实现方法" class="headerlink" title="里氏替换原则的实现方法"></a>里氏替换原则的实现方法</h4><p><font color="red">子类可以扩展父类的功能，但不能改变父类原有的功能。</font>即子类继承父类时，除了添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>通过重写父类的方法，会使整个继承体系的可复用性变差。尤其是在频繁使用<strong>多态</strong>的时候，程序运行出错概率会很大。程序违背里氏替换原则需要取消原继承关系，并重新设计其关系。</p><p>示例：“几维鸟不是鸟”</p><h3 id="依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle，DIP）"></a>依赖倒置原则（Dependence Inversion Principle，DIP）</h3><h4 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h4><p><font color="red">高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要<strong>面向接口编程</strong>，不要面向实现编程。</font></p><p>因为在软件设计中，细节具有多变性，而抽象层相对稳定，意思就是抽象层决定大方向，只要大方向没有错，具体怎么走的就看各人实现，相互之间的关联便是接口和实现类。</p><p>使用接口和抽象类的目的就是制定好规范和契约，而不去涉及具体实现和操作，把细节实现人物交给其实现类去完成。</p><h4 id="依赖倒置原则的作用"><a href="#依赖倒置原则的作用" class="headerlink" title="依赖倒置原则的作用"></a>依赖倒置原则的作用</h4><ul><li><strong>降低类之间的耦合度</strong></li><li>提高系统稳定性</li><li>减少并行开发引起的风险</li><li>提高代码的可读性和可维护性</li></ul><h4 id="依赖倒置原则的实现方法"><a href="#依赖倒置原则的实现方法" class="headerlink" title="依赖倒置原则的实现方法"></a>依赖倒置原则的实现方法</h4><p>依赖倒置原则的目的是通过要<strong>面向接口的编程来降低类间的耦合性</strong></p><ul><li>每个类尽量提供接口或者抽象类，或者两者兼备</li><li>变量的声明类型尽量是接口或者是抽象类</li><li>任何类不应该从具体类派生</li><li>使用继承时尽量遵守里氏替换原则</li></ul><p>尽量所有的类都设计接口和抽象类，所有的对象都有相应的类去描述，尽量这样才可以降低类之间的耦合度。</p><p>示例：不同的用户去不同的商店买不同的东西</p><h3 id="单一职责原则（Single-Responsibility-Principle，SRP）"><a href="#单一职责原则（Single-Responsibility-Principle，SRP）" class="headerlink" title="单一职责原则（Single Responsibility Principle，SRP）"></a>单一职责原则（Single Responsibility Principle，SRP）</h3><h4 id="单一职责原则的定义"><a href="#单一职责原则的定义" class="headerlink" title="单一职责原则的定义"></a>单一职责原则的定义</h4><p><font color="red">一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）</font></p><p>对象不应该承担太多职责，如果一个对象承担太多职责，会存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或者代码浪费</li></ol><h4 id="单一职责原则的优点"><a href="#单一职责原则的优点" class="headerlink" title="单一职责原则的优点"></a>单一职责原则的优点</h4><p><font color="red">单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。</font></p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多</li><li>提高类的可读性。降低其复杂性，可读性自然提高</li><li>提高系统可维护性。可读性提高，可维护性自然容易</li><li>变更引起的风险降低。当修改一个功能时，可以显著降低对其他功能的影响</li></ul><h4 id="单一职责原则的实现方法"><a href="#单一职责原则的实现方法" class="headerlink" title="单一职责原则的实现方法"></a>单一职责原则的实现方法</h4><p><font color="red">在发现类具有不同职责的时候，需要将其分离再封装到不同的类或者模块中。</font></p><p>示例：大学学生工作管理，学生工作即包含生活辅导也包含学业辅导，所以需要将其分离并再次封装到两个不同的类中，生活辅导为辅导员，学业辅导为学业导师。</p><h3 id="接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="接口隔离原则（Interface Segregation Principle，ISP）"></a>接口隔离原则（Interface Segregation Principle，ISP）</h3><h4 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h4><p><font color="red">客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）</font></p><p><font color="red">一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）</font></p><p>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责原则都是为了提高类的内聚性，降低他们的耦合性，体现了<strong>封装</strong>的思想，但是仍有不同：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要是约束接口，主要是针对抽象和程序整体框架的构建</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/SpringBoot%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/12/29/SpringBoot%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot框架"><a href="#SpringBoot框架" class="headerlink" title="SpringBoot框架"></a>SpringBoot框架</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><blockquote><p>简介</p></blockquote><p>SpringBoot是一个简化Spring开发框架，用来监护Spring应用开发，<font color="red">约定大于配置</font>，just run can set up a produce-framework 。</p><blockquote><p>优点</p></blockquote><ul><li>快速创建独立运行Spring项目及主流框架集成</li><li>使用<font color="red">嵌入式的Servlet容器</font>，应用无需打成WAR包</li><li>starters自动依赖与版本控制</li><li>准生产环境运行时应用监控</li><li>与云计算天然集成</li></ul><blockquote><p>单体应用与微服务</p></blockquote><p><font color="red">单体应用</font>是把所有的应用模块都写在一个应用中，会导致项目越来越大，模块之间的耦合度也会越来越高。</p><p><font color="red">微服务</font>是一种架构风格，用微服务科技将应用的模块单独部署，对不同的模块可以进行不同的管理操作，不同的模块生成小型服务，每个功能元素最后都可以成为一个可以独立替换，独立升级的功能单元，各个小型服务之间通过<font color="000fff">http</font>进行通讯。</p><blockquote><p>SpringBoot 的核心特点</p></blockquote><ol><li>微服务</li></ol><p>使用SpringBoot可以生成独立的微服务功能单元</p><ol start="2"><li>自动配置</li></ol><p>针对很多Spring应用程序常见的应用功能，SpringBoot能自动提供相关配置</p><ol start="3"><li>起步依赖</li></ol><p>告诉SpringBoot需要什么功能，她就能够引入需要的库</p><ol start="4"><li>命令行界面</li></ol><p>这是SpringBoot的可选特性，借此只需写代码就能完成完整的应用程序，无需项目构建</p><ol start="5"><li>Actuator</li></ol><p>深入运行SpringBoot应用程序</p><blockquote><p>Spring的MVC框架</p></blockquote><ul><li>模型（model）封装了应用程序数据，通常由POJO类类组成</li><li>视图（view）负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出</li><li>控制器（Controller）负责处理用户请求并构建恰当的模型，并将其传递给视图进行渲染</li></ul><blockquote><p>注入依赖（DI）</p></blockquote><p>Spring最认同的技术是控制翻转（IoC）的依赖注入（DI）模式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/Linux%20%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/12/29/Linux%20%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-指令"><a href="#Linux-指令" class="headerlink" title="Linux 指令"></a>Linux 指令</h1><h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><blockquote><p>ls pwd cd mkdir touch cp rm vim 输出重定向 cat</p></blockquote><h2 id="进阶指令"><a href="#进阶指令" class="headerlink" title="进阶指令"></a>进阶指令</h2><blockquote><p>df [-h] 指令</p></blockquote><p>查看<font color="red">磁盘空间</font>，-h表示以较高可读性的格式展示</p><blockquote><p>free [-m] [-g] 指令</p></blockquote><p>查看<font color="red">内存使用情况</font> ，-m表示以mb为单位进行查看</p><p>swap用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存</p><blockquote><p>head [-n] &lt;filename&gt; 指令</p></blockquote><p>查看一个文件的前n行，如果不指定n，则默认查看前10行</p><blockquote><p>tail [-n] &lt;filename&gt;指令</p></blockquote><p>查看一个文件的末n行，如果不指定n，则默认查看末10行</p><blockquote><p>tail -f &lt;filepath&gt; 指令</p></blockquote><p>通过tail -f指令查看一个文件的动态变化，该命令一般用于查看日志，用户手动加是无法生效的，只有系统自动加才会生效</p><blockquote><p>less &lt;filepath&gt; 指令</p></blockquote><p>查看文件，以较少的内容进行输出，按下辅助功能键(数字+回车键、空格键、上下方向键)查看更多</p><blockquote><p>wc [-lwc] &lt;filepath&gt;指令</p></blockquote><p>统计文件内容信息（包括行数-l，单词数-w(依照空格来判断单词数量)，字节数-c）</p><blockquote><p>date [+%F]指令<font color="red"> (重点)</font></p></blockquote><p>表示操作时间日期（读取，设置）</p><p>例：date “+%F %T”引号表示让年月日和时分秒成为一个不可分割的整体,等价于date “+%Y-%m-%d %H:%M:%S”</p><p>date +%F 等价于 date “+%Y-%m-%d”</p><blockquote><p>date 获取时间</p></blockquote><p>date -d “-1 day” “+%Y-%m-%d %H:%M:%S”获取之前（之后）时间</p><p>符号的可选值：“+” 表示之后 “-”表示之前</p><p>单位的可选值：day（天）、month（月）、year（年）</p><p>%F表示完整的年月日</p><p>%T表示完整的时分秒</p><p>%Y表示四位年份</p><p>%m表示两位月份，带前导0</p><p>%d表示日期，带前导0</p><p>%H表示小时，带前导0</p><p>%M表示分钟，带前导0</p><p>%S表示秒，带前导0</p><blockquote><p>cal [-n] [-s/m]指令/cal -y &lt;year&gt;</p></blockquote><p>日历，输出n个月的日历，当前月周边n个月</p><blockquote><p>clear/(ctrl +L) 指令</p></blockquote><p>将终端中已经存在的命令和结果（信息）隐藏到上面，可以通过滚动条查看之前信息</p><blockquote><p>管道<font color="red">(重要)</font></p></blockquote><p>管道符 ： |</p><p>作用： 管道一般可以用于“过滤”，“特殊”，“扩展处理”</p><p>语法：管道不能单独使用，必须要配合前面所讲的一些指令一起使用，起协助作用。</p><p><font color="red"><strong>过滤</strong></font>：ls / | grep y</p><ul><li><p>管道作为分界线，前面的命令有个输出，后面的需要先输入，然后再过滤，最后再输出。简而言之，<font color="red">管道前面的输出就是后面指令的输入</font>。</p></li><li><p>grep指令：主要用于过滤</p></li></ul><p>特殊：通过管道操作方法实现less等价效果 #cat &lt;file&gt; | less</p><p>扩展处理：统计某个目录下的文档总个数？#ls / | wc -l</p><h2 id="高级指令"><a href="#高级指令" class="headerlink" title="高级指令"></a>高级指令</h2><blockquote><p>hostname 指令</p></blockquote><p>作用：操作服务器<font color="red">主机名</font>（<font color="red">读取</font>，设置）</p><p>语法：</p><ul><li><p>hostname     含义：查看主机名，输出完整主机名</p></li><li><p>hostname -f 含义：表示输出当前主机名的FQDN（全限定域名）</p></li></ul><blockquote><p>id 指令</p></blockquote><p>作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…）</p><p>语法：</p><ul><li>id 含义：默认显示当前执行该命令的用户的基本信息</li><li>id &lt;userid&gt; 含义：显示指定用户的基本信息</li></ul><p>验证上述信息是否正确？</p><p>验证用户信息：通过文件/etc/passwd</p><p>验证用户组信息：通过文件/etc/group</p><blockquote><p>whoami 指令</p></blockquote><p>作用：显示当前登陆的用户名，一般用于shell脚本，用于获取当前操作的用户名方便记录在日志上。</p><blockquote><p>ps -ef 指令 <font color="red">（重点）</font></p></blockquote><p>指令：ps</p><p>作用：主要是查看服务器的进程信息</p><p>选项含义：</p><ul><li>-e ： 等价于”-A“，表示列出全部进程信息</li><li>-f ： 显示全部的列（显示全字段）</li></ul><p>列含义：</p><p>UID：该进程执行的用户id</p><p><font color="red">PID</font>：进程id</p><p><font color="red">PPID</font>：该进程的父级进程id，如果一个程序的父级进程找不到，该程序称之为僵尸进程</p><p><font color="red">C/CPU</font>：CPU占用率，其形式为百分数</p><p>STIME：进程的启动时间</p><p>TTY：终端设备，发起该进程的设备识别符号，如果显示“？”则表示该进程并不是由终端设备发起的</p><p>TIME：进程的执行时间</p><p>CMD：该进程的名称或者对应的路径</p><p>案例： ps -ef | grep 查看目标进程  <font color="red">（高使用）</font></p><blockquote><p>top 指令</p></blockquote><p>作用：查看服务器进程占用资源</p><p>语法：</p><ul><li>进入命令 top 动态显示</li><li>退出命令 按q键</li></ul><p>列含义：</p><p>PID：进程id</p><p>USER：该进程对应的用户</p><p>PR：优先级</p><p>NI：用户进程空间内改变过进程所占的百分比</p><p>VIRT：虚拟内存</p><p>RES：常驻内存</p><p>SHR：共享内存</p><p>计算一个进程实际使用的内存 = 常驻内存（RES）－　共享内存（SHR）</p><p> <font color="red">S</font>：表示进行的状态（５种状态　运行（Ｒ），睡眠（Ｓ））</p><p> <font color="red">％CPU</font>：表示CPU的占用百分比</p><p> <font color="red">％MEM</font>：表示内存的占用百分比</p><p>TIME+：执行的时间</p><p> <font color="red">COMMAND</font>：进程的名称或者路径</p><p>在运行top的时候，可以按下方便的快捷键：</p><p>M：表示将结果按照内存（MEM）从高到低进行降序排列</p><p>P：表示将结果按照CPU使用率从高到低进行降序排列</p><p>1：当服务器拥有多个cpu的时候，可以使用1来切换展示各个CPU的详细信息</p><blockquote><p>dh -sh 指令</p></blockquote><p>作用：查看目录的真实大小</p><p>选项含义：</p><ul><li>-s： summaries，只显示汇总的大小</li><li>-h： 表示以较高可读性形式展示</li></ul><blockquote><p>find 指令</p></blockquote><p>作用：用于查找文件（其参数有55个之多）</p><p>语法：</p><ul><li><p>find &lt;path&gt; [选项] [选项的值]</p><p>选项：</p><ul><li><p>-name: 按照文档名称进行搜索(支持模糊搜索)</p></li><li><p>-type：按照文档的类型进行搜索</p></li></ul><p>  [^ 注]: 文档类型，“-”表示文件（在使用find的时候需要用f来替换），“d”表示文件夹</p></li></ul><p>案例：</p><ul><li>查看/etc下所有的文件并计数：find /etc/ -type f | wc -l</li><li>查看/etc下所有的文件夹并计数：find /etc/ -type d| wc -l</li></ul><blockquote><p>service 指令</p></blockquote><p>作用：用于控制一些软件的服务启动/停止/重启</p><p>语法：service [服务名] start/stop/restart</p><p>通过ps查看服务是否启动</p><blockquote><p>kill 指令</p></blockquote><p>作用：杀死进程</p><p>语法：kill PID 、killall PID</p><blockquote><p>ifconfig 指令</p></blockquote><p>作用：用于操作网卡相关指令</p><blockquote><p>reboot 指令</p></blockquote><p>作用：重启计算机</p><p>语法：（了解）reboot [-w] 模拟重启，但是不重启，只写开关机日志但是不重启</p><blockquote><p>shutdown 指令</p></blockquote><p>作用：关机（慎用）</p><p>语法：shutdown -h now 立即重启 shotdown -h 15:25 “关机提示” 定时重启</p><blockquote><p>uptime 指令</p></blockquote><p>作用：输出计算机的持续在线时间</p><blockquote><p>uname [-a]指令</p></blockquote><p>作用：获取计算机操作系统的相关信息(类型，主机名，内核版本，发布时间，开源计划)</p><blockquote><p>netstat -tnlp 指令</p></blockquote><p>作用：查看网络的连接状态</p><p>选项说明：</p><p>-t：表示只列出tcp协议的连接</p><p>-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示</p><p>-l： 表示过滤出“state”状态列中其值为LISTEN（监听）的连接</p><p>-p：表示显示发起连接的进行pid和进程名称</p><blockquote><p>man 指令</p></blockquote><p>作用：manual 手册（包含了Linux中全部命令手册）</p><p>语法：man [命令] 按q退出</p><h2 id="VIM编辑器"><a href="#VIM编辑器" class="headerlink" title="VIM编辑器"></a>VIM编辑器</h2><p>vim的三种常见模式：<strong>命令模式</strong>、<strong>编辑模式</strong>、<strong>末行模式</strong></p><p>末行模式-&gt;搜索，替换，保存，退出，撤销，高亮等</p><p>vim打开文件的方式：</p><ul><li>vim filepath</li><li>vim +num +filepath 打开文件并将光标移动到指定行</li><li>vim +/key filepath 打开指定文件并高亮显示key</li><li>vim filepath1 filepath2 打开多个文件</li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ol><li>光标移动</li></ol><ul><li>光标移动到行首  <code>^</code></li></ul><blockquote><p>按键：shift+6（T字母上的6）即^</p></blockquote><ul><li>光标移动到行尾 <code>$</code></li></ul><blockquote><p>按键：shift+4 （R字母左上角的4） 即$</p></blockquote><ul><li>光标移动到首行 <code>gg</code></li></ul><blockquote><p>按键：gg</p></blockquote><ul><li>光标移动到末行 <code>G</code></li></ul><blockquote><p>按键：G</p></blockquote><ul><li>翻屏</li></ul><blockquote><p>向上翻屏： 按键 ctrl+b 或者PgUp</p><p>向下翻屏： 按键 ctrl+f  或者 PgDn</p></blockquote><ol start="2"><li>复制操作</li></ol><ul><li>复制光标所在行<code>yy</code> <code>p</code></li></ul><blockquote><p>按键： yy</p><p>粘贴：（想要复制的地方）p</p></blockquote><ul><li>复制多行 <code>yy</code></li></ul><p>以光标所在行为准（包含当前行），向下复制指定行数</p><blockquote><p>按键：数字 yy</p></blockquote><ul><li>复制可视块</li></ul><blockquote><p>按键：ctrl+v 然后通过 $\uparrow、\downarrow、\rightarrow、\leftarrow$ 来选中可视块，然后按下<code>yy</code>和<code>p</code>进行复制粘贴</p></blockquote><ol start="3"><li>剪切/删除 </li></ol><ul><li>删除光标所在行（删除之后下一行上移） <code>dd</code></li></ul><blockquote><p>按键：dd</p></blockquote><ul><li>剪切/删除光标所在行为准（包含当前行），向下删除/剪切指定的行数<code>dd</code></li></ul><blockquote><p>按键： 数字 dd</p></blockquote><ul><li>删除光标所在行，下一行不上移 <code>D</code></li></ul><blockquote><p>按键：D</p></blockquote><ol start="4"><li>撤销/恢复</li></ol><p>撤销： 输入 <code>:u</code> 或者 <code>u</code></p><p>恢复：ctrl+r</p><ol start="5"><li>光标的快速移动</li></ol><ul><li>快速将光标移动到指定的行</li></ul><blockquote><p>数字 G</p></blockquote><ul><li>以当前光标为准向上/下移动n行</li></ul><blockquote><p>按键 ： 数字 $\uparrow$ ,数字 $\downarrow$ </p></blockquote><ul><li>以当前光标向左/右移动n行</li></ul><blockquote><p>按键：  数字 $\leftarrow$ ,数字 $\rightarrow$ </p></blockquote><h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><p>进入方式：由命令模式，按<code>:</code> 进入</p><p>保存： <code>:w</code></p><p>另存： <code>:w &lt;path&gt;</code></p><p>退出： <code>:q</code></p><p>保存并退出： <code>:wq</code></p><p>强制：<code>:q!</code></p><p>调用外部命令： <code>:! 外部命令</code></p><p>搜索/查找： <code>/ &lt;key&gt;</code> </p><p>在搜索结果中切换上一个和下一个N/n</p><p>取消高亮： <code>:nohl</code></p><p>替换： <code>:s/key/newStr</code> 替换光标所在行的第一处符合条件的字符串</p><p><code>:s/key/newStr/g</code> 替换光标所在行的所有符合条件的字符串</p><p><code>:%s/key/newStr</code>替换整个文档中所有行的第一个符合条件的字符串</p><p><code>:%s/key/newStr/g</code> 替换整个文档中所有行的所有符合条件的字符串</p><p>显示行号： <code>:set nu</code></p><p>取消显示行号： <code>:set nonu</code></p><p><strong>切换vim打开的多个文件：</strong></p><ul><li>查看当前已经打开文件的名称 ： <code>:files</code></li></ul><blockquote><p>#表示打开的上一个文件，%a表示当前文件</p></blockquote><p>指定切换文件名称： <code>:open &lt;opened filename&gt; </code> </p><ul><li><p>打开上一个文件： <code>:bp</code> </p></li><li><p>打开下一个文件： <code>bn</code></p></li></ul><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>进入方式 <code>i</code> 或者 <code>a</code></p><p>代码着色： 关闭显示：<code>:syntax off</code>   开启显示 ： <code>syntax on</code></p><p>vim 计算器使用： <code>ctrl + R | =</code> </p><h3 id="vim的配置"><a href="#vim的配置" class="headerlink" title="vim的配置"></a>vim的配置</h3><ul><li>在文件打开的时候在末行模式下输入的配置（临时的）</li><li>个人配置文件（~/.vimrc）如果没有，可以自行新建</li><li>全局配置文件（vim自带，/etc/vimrc）</li></ul><p>linux别名映射文件 ~/.bashrc</p><h2 id="Linux-7中运行级别-模式"><a href="#Linux-7中运行级别-模式" class="headerlink" title="Linux 7中运行级别/模式"></a>Linux 7中运行级别/模式</h2><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><p>0 —— 表示关机级别（不要将默认的运行级别设置成0）</p><p>1 —— 表示单用户模式</p><p>2 —— 表示多用户模式，不带NFS（NetWork File System）</p><p>3 —— 表示多用户模式，完全的多用户模式</p><p>4 —— 没有被使用的模式（被保留的模式）</p><p>5 —— X11，完整的图形化界面模式</p><p>6 —— 表示重启级别（不要将默认的运行模式设置成6）</p><h3 id="SSH服务-重要"><a href="#SSH服务-重要" class="headerlink" title="SSH服务(重要)"></a><font color="red">SSH服务(重要)</font></h3><p>ssh（secure shell，安全外壳协议），该协议有两个常用作用：<font color="red">远程连接协议</font>、<font color="red">远程文件传输协议</font></p><p>服务启动/停止/重启</p><p><code>$ service sshd start/stop/restart</code></p><p><code>$ /etc/init.d/sshd start/stop/restart</code></p><h4 id="远程终端"><a href="#远程终端" class="headerlink" title="远程终端"></a>远程终端</h4><p>常见远程终端工具：Xshell，secure CRT，putty</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/jenkins%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2020/12/29/jenkins%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="jenkins流水线"><a href="#jenkins流水线" class="headerlink" title="jenkins流水线"></a>jenkins流水线</h1><p>Jenkins 流水线 (或简单的带有大写”P”的”Pipeline”) 是一套插件，它支持实现和集成 <em>continuous delivery pipelines</em> 到 Jenkins。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/29/Dockerfile%20%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99/"/>
    <url>/2020/12/29/Dockerfile%20%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile-编写"><a href="#Dockerfile-编写" class="headerlink" title="Dockerfile 编写"></a>Dockerfile 编写</h1><p>先放个简单例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">get base docker</span><br>FROM centos/systemd<br><br><span class="hljs-meta">#</span><span class="bash"> Maintainer massage</span><br>MAINTAINER xxx@xxx.com<br><br><span class="hljs-meta">#</span><span class="bash"> install foundamental packages and utilities packages</span><br>RUN yum install -y cmake make vim tree wget curl gzip zip unzip git sox &amp;&amp; \<br>    yum install -y openssl openssh-server openssh-client <br><br><span class="hljs-meta">#</span><span class="bash"> Switch working path to /root</span><br>WORKDIR /root    <br><br><span class="hljs-meta">#</span><span class="bash"> copy loacl file to docker</span><br>ADD jdk-8u45-linux-x64.tar.gz /usr/local<br>ENV JAVA_HOME /usr/local/jdk1.8.0_45<br><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span> Environment</span><br>ENV CPPFLAGS -UPHNALG<br><br>WORKDIR /var/localbag/lame-3.100/<br>RUN ./configure --prefix=/usr/local/ --enable-shared &amp;&amp; \<br>    make &amp;&amp; make install<br><br><span class="hljs-meta">#</span><span class="bash"> expose port 8222</span><br>EXPOSE 8222<br><br><span class="hljs-meta">#</span><span class="bash"> like as CMD，but be not covered by CMD</span><br>ENTRYPOINT [&quot;/root/run.sh&quot;]<br><br><span class="hljs-meta">#</span><span class="bash"> startup script when docker running</span><br>CMD [&quot;/usr/sbin/init&quot;,&quot;/root/run.sh&quot;]<br></code></pre></td></tr></table></figure><p>从上面得基础示例可以看出Dockerfile主要分为四个部分：</p><ul><li>基础镜像信息 </li></ul><blockquote><p>FROM</p></blockquote><p>FROM 是为了指明构建的镜像是出自哪个基础镜像的，在此基础上加上些保证我们应用服务可以正常运行的软件，如上面示例的cmake、make、vim等，</p><p>docker基础镜像可以从docker-hub上寻找拉取下载</p><ul><li>维护者信息</li></ul><blockquote><p>MAINTAINER / LABEL</p></blockquote><p>通过MAINTAINER / LABEL来指明该镜像的维护者或其联系方式；</p><p>LABEL可以给镜像增加（多个）标签记录信息</p><ul><li><strong>镜像操作指令</strong></li></ul><blockquote><p>RUN</p></blockquote><p>用于构建镜像时运行的shell命令，如安装扩展软件，环境配置等</p><p>[^ 注1]: 你应该避免使用<code>RUN apt-get upgrade</code>或者<code>dis-upgrade</code>, 因为父镜像中许多”基本的”(essential)包不能在容器中升级。<br>[^ 注2]: 使用<code>RUN apt-get update &amp;&amp; apt-get install -y</code>可以确保你的<code>Dockerfile</code>安装最新版本的软件包而无需编码或手动干预。</p><blockquote><p>ADD / COPY</p></blockquote><p>ADD和COPY都可以拷贝文件或者目录到镜像中，但是ADD后如果是URL那么就会自动下载或者是自动解压，而COPY不支持自动下载和解压</p><blockquote><p>WORKDIR</p></blockquote><p>用于设置工作目录，和RUN cd都有切换目录的作用，但是WORKDIR为docker进行工作目录切换，而RUN cd只是在RUN中的一步，暂时切换，RUN执行结束后失效</p><blockquote><p>ENV</p></blockquote><p>设置环境变量 ，如上例<code>ENV CPPFLAGS -UPHNALG</code></p><blockquote><p>VOLUME</p></blockquote><p>指定容器挂载点到宿主机自动生成的目录或其他容器，和docker run -v效用一样，但是后者更常见</p><ul><li>容器启动时执行命令</li></ul><blockquote><p>EXPOSE</p></blockquote><p>声明容器运行服务端口</p><blockquote><p>ENTRYPOINT</p></blockquote><p>启动容器时执行的shell命令或是脚本，由ENTRYPOINT启动的命令或是脚本不会被覆盖，ENTRYPOINT可以有多条，但是只有最后一条会生效；但是docker run的–entrypoint选项的参数可覆盖ENTRYPOINT指定的默认程序。</p><blockquote><p>CMD</p></blockquote><p>启动容器时执行的shell命令或是脚本，Dockerfile中CMD可以有多条，但是只有最后一条会生效</p><p>到此，创建好Dockerfile后，便可以创建镜像了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t test-docker:v0.1 .<br></code></pre></td></tr></table></figure><p><strong>镜像名不能有大写哦</strong></p><p>注：</p><ol><li>docker 层数最小化</li></ol><p>在保证Dockerfile可读性（从而可以长时间维护）的同时也需要兼顾dockerfile的层数最小化。</p><ol start="2"><li>构建缓存</li></ol><p>在构建镜像的过程中，Docker会<strong>逐句</strong>读取你Dockerfile中的指令按指定的顺序执行。因为每个指令都会被检查Docker会在它的缓存中查找可以重用的现有镜像，而不是创建一个新的（重复的）镜像。如果你根本不想使用缓存，你可以对 <code>docker build</code> 命令使用 <code>--no-cache=ture</code>参数。</p><ol start="3"><li> 检查缓存</li></ol><p>除了<code>ADD</code>和<code>COPY</code>命令以外，缓存检查将不会检查容器中的文件来确定缓存匹配。比如，当处理一个<code>RUN apt-get -y update</code>容器中的文件更新将不会被检查来确定是否命中已存在缓存。在这种情况下只有命令字符串自己将被用来查找匹配。一旦缓存失效，那么后面所有的Dockerfile命令将会生成新的镜像而不会使用缓存。</p><p>attach Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像<br>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像<br>commit    Create a new image from a container changes   # 提交当前容器为新的镜像<br>cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中<br>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器<br>diff      Inspect changes on a container’s filesystem   # 查看 docker 容器变化<br>events    Get real time events from the server          # 从 docker 服务获取容器实时事件<br>exec      Run a command in an existing container        # 在已存在的容器上运行命令<br>export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]<br>history   Show the history of an image                  # 展示一个镜像形成历史<br>images    List images                                   # 列出系统当前镜像<br>import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]<br>info      Display system-wide information               # 显示系统相关信息<br>inspect   Return low-level information on a container   # 查看容器详细信息<br>kill      Kill a running container                      # kill 指定 docker 容器<br>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]<br>login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器<br>logout    Log out from a Docker registry server          # 从当前 Docker registry 退出<br>logs      Fetch the logs of a container                 # 输出当前容器日志信息<br>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口<br>pause     Pause all processes within a container        # 暂停容器<br>ps        List containers                               # 列出容器列表<br>pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像<br>push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器<br>restart   Restart a running container                   # 重启运行的容器<br>rm        Remove one or more containers                 # 移除一个或者多个容器<br>rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]<br>run       Run a command in a new container              # 创建一个新的容器并运行一个命令<br>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]<br>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像<br>start     Start a stopped containers                    # 启动容器<br>stop      Stop a running containers                     # 停止容器<br>tag       Tag an image into a repository                # 给源中镜像打标签<br>top       Lookup the running processes of a container   # 查看容器中运行的进程信息<br>unpause   Unpause a paused container                    # 取消暂停容器<br>version   Show the docker version information           # 查看 docker 版本号<br>wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/12/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/12/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h3><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="第一节-1"><a href="#第一节-1" class="headerlink" title="第一节"></a>第一节</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/29/hello-world/"/>
    <url>/2020/12/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
